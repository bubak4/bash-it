#!/bin/bash
# Time-stamp: <2025-10-11 12:59:06 martin>
# gitw -- git wrapper for multiple repositories

# SCRIPTPATH="$( cd "$(dirname "$0")" ; pwd -P )"
# cd $SCRIPTPATH || exit 1

UPSTREAM=${UPSTREAM:-"origin"}
MASTER_BRANCH=${MASTER_BRANCH:-"master"}
DEFAULT_BRANCHES=${DEFAULT_BRANCHES:-"master,release,dev"}
REPOS="" # will be set later from config file

# parse the DEFAULT_BRANCHES variable into an array
IFS=',' read -ra BRANCH_ARRAY <<< "$DEFAULT_BRANCHES"
for branch in "${BRANCH_ARRAY[@]}"; do
    echo "Working on branch: $branch" >/dev/null # just suppress the notification
done

function usage() {
    echo "Usage: $(basename $0) [cmd-merge|cmd-push|cmd-log|branch-{create|delete|list}|<git-command>]"
    echo
    echo "cmd-merge                ... merge all default branches into each other"
    echo "cmd-push                 ... push all default branches to upstream"
    echo "cmd-log                  ... log unpushed commits to upstream"
    echo "branch-create <branch>   ... create a new branch in all repos based on current branch"
    echo "branch-delete <branch>   ... delete a branch in all repos (both local and remote)"
    echo "branch-list              ... list all branches in all repos"
    echo "<git-command>            ... any git command, e.g. status, pull, checkout, commit, push, merge, etc."
    echo
    echo "Environment variables:"
    echo "  UPSTREAM=$UPSTREAM   ... set to upstream name"
    echo "  MASTER_BRANCH=$MASTER_BRANCH   ... set to name of a master/main branch"
    echo "  DEFAULT_BRANCHES=$DEFAULT_BRANCHES   ... set to name of a branches that are used for cmd-merge/cmd-push commands"
    exit 1
}

function comment_line() {
    local text="$1"
    echo ">> $text <<"
}

function comment_box() {
    local text="$1"
    local length=${#text}
    local border=$(printf '+%*s+\n' "$((length + 2))" '' | tr ' ' '-')

    echo "$border"
    echo "| $text |"
    echo "$border"
}

function find_config() {
    local cwd=$(pwd)
    local cfg_files=".gitwrapper .gitw"

    # Loop until we find .git-mine or reach the home directory
    while test "$cwd" != "/" ; do
        for cfg in $cfg_files ; do
            if test -f "$cwd/$cfg" ; then
                echo "${cwd}/${cfg}"
                return 0
            fi
        done
        cwd=$(dirname "$cwd")
    done
    return 1
}

# $1 .. cfg
function find_repos() {
    local cfg=$1

    if test -z "$cfg" ; then
        echo "unable to find config"
        exit 1
    fi

    for i in $(cat $cfg) ; do
        repo=$(realpath $(dirname $cfg)/$i)
        if test -d $repo -a -d $repo/.git ; then
            echo "$repo"
        fi
    done
}

# does not work very well (symlinks, terraform module referencing .git tags etc.)
function find_repos_fallback() {
    find $(pwd) -name .git -exec dirname {} \; 2>/dev/null
}

# "$@" .. command pass to git over repos
# uses global REPOS variable
function run_command() {
    comment_box "Running: git $*"
    for repo in $REPOS ; do
        cd $repo
        comment_line $(basename $repo)
        git "$@" || {
            echo "ERROR: \"git $*\" in $repo"
            #exit 1
        }
    done
    comment_box "Done: git $*"
}

function create_default_branches() {
    $0 checkout $MASTER_BRANCH
    for i in "${BRANCH_ARRAY[@]}"; do
        if test "$i" = "$MASTER_BRANCH" ; then
            continue
        fi
        $0 checkout -b $i $MASTER_BRANCH
        $0 push -u $UPSTREAM $i
    done
}

function merge_all() {
    for i in "${BRANCH_ARRAY[@]}"; do
        $0 checkout $i
        $0 pull $UPSTREAM $i
    done

    log=""
    for i in "${BRANCH_ARRAY[@]}"; do
        $0 checkout $i
        for j in "${BRANCH_ARRAY[@]}"; do
            if test "$i" = "$j" ; then
                continue
            fi
            $0 merge $j
            log="$log\nmerge $i -> $j"
        done
    done
    comment_box "$(comment_line "Merge Summary")"
    echo -e "\nUPSTREAM=$UPSTREAM"
    echo -e $log
}

function push_all() {
    log=""
    for i in "${BRANCH_ARRAY[@]}"; do
        $0 checkout $i
        $0 push "$UPSTREAM"
        log="$log\npush ${UPSTREAM}/${i}"
    done
    comment_box "$(comment_line "Push Summary")"
    echo -e "\nUPSTREAM=$UPSTREAM"
    echo -e $log
}

function log_unpushued() {
    local logfile=$(mktemp /tmp/gitw-log.XXXXXX) || exit 1
    # Check if upstream exists, otherwise use origin/current_branch
    if git rev-parse --verify "@{upstream}" >/dev/null 2>&1; then
        gitw --no-pager log --pretty=format:%s "@{upstream}..HEAD" > $logfile
    else
        current_branch=$(git rev-parse --abbrev-ref HEAD)
        gitw --no-pager log --pretty=format:%s "origin/$current_branch..HEAD" 2>/dev/null || echo "No remote branch found" > $logfile
    fi

    cat $logfile | \
        awk '
    # Step 1: Remove all empty lines and collect non-empty lines
    NF > 0 { lines[++count] = $0 }

    END {
        # Step 2: Process each line and handle patterns
        for (i = 1; i <= count; i++) {
            line = lines[i]

            # First handle +...+ pattern (only if in middle of line)
            if (match(line, /\+[^+]+\+/)) {
                before_plus = substr(line, 1, RSTART-1)
                plus_pattern = substr(line, RSTART, RLENGTH)
                after_plus = substr(line, RSTART+RLENGTH)

                # Clean up whitespace
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", before_plus)
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", after_plus)

                # Only process if +...+ starts in the middle (has content before, but no content after)
                if (before_plus != "" && after_plus == "") {
                    print before_plus
                    print ""
                    print plus_pattern
                    continue  # Skip to next line
                }
                # If not in middle, fall through to process normally
            }

            # Then handle >>...<< pattern
            if (match(line, />>[^<]*<</)) {
                before = substr(line, 1, RSTART-1)
                pattern = substr(line, RSTART, RLENGTH)
                after = substr(line, RSTART+RLENGTH)

                # Clean up whitespace
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", before)
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", after)

                # Print before text if it exists
                if (before != "") {
                    print before
                }

                # Always add empty line before pattern
                print ""
                print pattern
                print ""

                # Print after text if it exists
                if (after != "") {
                    print after
                }
            } else {
                # Regular line - just print it
                print line
            }
        }
    }'
    rm -f $logfile
}

function branch_create() {
    local branch_name="$1"
    if test -z "$branch_name" ; then
        echo "branch-create requires a branch name"
        exit 1
    fi
    # Create branch in all repos based on current branch
    run_command checkout -b "$branch_name"
    # Push branch to upstream and track it
    run_command push --set-upstream "$UPSTREAM" "$branch_name"
}

function branch_delete() {
    local branch_name="$1"
    if test -z "$branch_name" ; then
        echo "branch-delete requires a branch name"
        exit 1
    fi
    # Local deletion
    #run_command branch --delete --force "$branch_name"
    run_command branch --delete "$branch_name"
    # Remote deletion
    run_command push origin --delete "$branch_name"
}

function branch_list() {
    run_command --no-pager branch --remotes --all --verbose
}

########
# main #
########

if cfg=$(find_config) ; then
    REPOS=$(find_repos $cfg)
else
    echo "Unable to find config file (.gitwrapper or .gitw)"
    exit 1
fi

if test "$1" = "cmd-merge" ; then
    echo "Using default branches: $DEFAULT_BRANCHES"
    merge_all
elif test "$1" = "cmd-push" ; then
    echo "Using default branches: $DEFAULT_BRANCHES"
    push_all
elif test "$1" = "cmd-log" ; then
    log_unpushued
elif test "$1" = "branch-create" ; then
    branch_create "$2"
elif test "$1" = "branch-delete" ; then
    branch_delete "$2"
elif test "$1" = "branch-list" ; then
    branch_list
elif test "$1" = "repos-list" ; then
    echo "Using config: $cfg"
    echo "$REPOS"
elif test -z "$1" ; then
    usage
else
    run_command "$@"
fi
